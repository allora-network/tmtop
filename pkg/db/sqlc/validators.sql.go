// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: validators.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createValidator = `-- name: CreateValidator :one
INSERT INTO validators (address, public_key, voting_power, moniker)
VALUES (?, ?, ?, ?)
RETURNING id, address, public_key, voting_power, moniker, created_at, updated_at
`

type CreateValidatorParams struct {
	Address     string         `json:"address"`
	PublicKey   string         `json:"public_key"`
	VotingPower int64          `json:"voting_power"`
	Moniker     sql.NullString `json:"moniker"`
}

func (q *Queries) CreateValidator(ctx context.Context, arg CreateValidatorParams) (Validator, error) {
	row := q.queryRow(ctx, q.createValidatorStmt, createValidator,
		arg.Address,
		arg.PublicKey,
		arg.VotingPower,
		arg.Moniker,
	)
	var i Validator
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.PublicKey,
		&i.VotingPower,
		&i.Moniker,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteValidator = `-- name: DeleteValidator :exec
DELETE FROM validators WHERE address = ?
`

func (q *Queries) DeleteValidator(ctx context.Context, address string) error {
	_, err := q.exec(ctx, q.deleteValidatorStmt, deleteValidator, address)
	return err
}

const getValidator = `-- name: GetValidator :one
SELECT id, address, public_key, voting_power, moniker, created_at, updated_at FROM validators WHERE address = ? LIMIT 1
`

func (q *Queries) GetValidator(ctx context.Context, address string) (Validator, error) {
	row := q.queryRow(ctx, q.getValidatorStmt, getValidator, address)
	var i Validator
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.PublicKey,
		&i.VotingPower,
		&i.Moniker,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getValidators = `-- name: GetValidators :many
SELECT id, address, public_key, voting_power, moniker, created_at, updated_at FROM validators ORDER BY voting_power DESC
`

func (q *Queries) GetValidators(ctx context.Context) ([]Validator, error) {
	rows, err := q.query(ctx, q.getValidatorsStmt, getValidators)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Validator{}
	for rows.Next() {
		var i Validator
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.PublicKey,
			&i.VotingPower,
			&i.Moniker,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidatorsByHeight = `-- name: GetValidatorsByHeight :many
SELECT v.id, v.address, v.public_key, v.voting_power, v.moniker, v.created_at, v.updated_at, vs.voting_power, vs.voting_power_percent, vs.is_proposer
FROM validators v
JOIN validator_snapshots vs ON v.address = vs.validator_address
WHERE vs.height = ?
ORDER BY vs.voting_power DESC
`

type GetValidatorsByHeightRow struct {
	ID                 int64           `json:"id"`
	Address            string          `json:"address"`
	PublicKey          string          `json:"public_key"`
	VotingPower        int64           `json:"voting_power"`
	Moniker            sql.NullString  `json:"moniker"`
	CreatedAt          sql.NullTime    `json:"created_at"`
	UpdatedAt          sql.NullTime    `json:"updated_at"`
	VotingPower_2      int64           `json:"voting_power_2"`
	VotingPowerPercent sql.NullFloat64 `json:"voting_power_percent"`
	IsProposer         sql.NullBool    `json:"is_proposer"`
}

func (q *Queries) GetValidatorsByHeight(ctx context.Context, height int64) ([]GetValidatorsByHeightRow, error) {
	rows, err := q.query(ctx, q.getValidatorsByHeightStmt, getValidatorsByHeight, height)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetValidatorsByHeightRow{}
	for rows.Next() {
		var i GetValidatorsByHeightRow
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.PublicKey,
			&i.VotingPower,
			&i.Moniker,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.VotingPower_2,
			&i.VotingPowerPercent,
			&i.IsProposer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateValidator = `-- name: UpdateValidator :one
UPDATE validators 
SET public_key = ?, voting_power = ?, moniker = ?, updated_at = CURRENT_TIMESTAMP
WHERE address = ?
RETURNING id, address, public_key, voting_power, moniker, created_at, updated_at
`

type UpdateValidatorParams struct {
	PublicKey   string         `json:"public_key"`
	VotingPower int64          `json:"voting_power"`
	Moniker     sql.NullString `json:"moniker"`
	Address     string         `json:"address"`
}

func (q *Queries) UpdateValidator(ctx context.Context, arg UpdateValidatorParams) (Validator, error) {
	row := q.queryRow(ctx, q.updateValidatorStmt, updateValidator,
		arg.PublicKey,
		arg.VotingPower,
		arg.Moniker,
		arg.Address,
	)
	var i Validator
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.PublicKey,
		&i.VotingPower,
		&i.Moniker,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertValidator = `-- name: UpsertValidator :one
INSERT INTO validators (address, public_key, voting_power, moniker)
VALUES (?, ?, ?, ?)
ON CONFLICT(address) DO UPDATE SET
    public_key = excluded.public_key,
    voting_power = excluded.voting_power,
    moniker = excluded.moniker,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, address, public_key, voting_power, moniker, created_at, updated_at
`

type UpsertValidatorParams struct {
	Address     string         `json:"address"`
	PublicKey   string         `json:"public_key"`
	VotingPower int64          `json:"voting_power"`
	Moniker     sql.NullString `json:"moniker"`
}

func (q *Queries) UpsertValidator(ctx context.Context, arg UpsertValidatorParams) (Validator, error) {
	row := q.queryRow(ctx, q.upsertValidatorStmt, upsertValidator,
		arg.Address,
		arg.PublicKey,
		arg.VotingPower,
		arg.Moniker,
	)
	var i Validator
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.PublicKey,
		&i.VotingPower,
		&i.Moniker,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
