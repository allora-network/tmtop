// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: rounds.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createRound = `-- name: CreateRound :one
INSERT INTO rounds (height, round_number, step, start_time, proposer_address)
VALUES (?, ?, ?, ?, ?)
RETURNING id, height, round_number, step, start_time, proposer_address, created_at
`

type CreateRoundParams struct {
	Height          int64          `json:"height"`
	RoundNumber     int64          `json:"round_number"`
	Step            sql.NullInt64  `json:"step"`
	StartTime       sql.NullTime   `json:"start_time"`
	ProposerAddress sql.NullString `json:"proposer_address"`
}

func (q *Queries) CreateRound(ctx context.Context, arg CreateRoundParams) (Round, error) {
	row := q.queryRow(ctx, q.createRoundStmt, createRound,
		arg.Height,
		arg.RoundNumber,
		arg.Step,
		arg.StartTime,
		arg.ProposerAddress,
	)
	var i Round
	err := row.Scan(
		&i.ID,
		&i.Height,
		&i.RoundNumber,
		&i.Step,
		&i.StartTime,
		&i.ProposerAddress,
		&i.CreatedAt,
	)
	return i, err
}

const deleteRoundsOlderThan = `-- name: DeleteRoundsOlderThan :exec
DELETE FROM rounds WHERE height < ?
`

func (q *Queries) DeleteRoundsOlderThan(ctx context.Context, height int64) error {
	_, err := q.exec(ctx, q.deleteRoundsOlderThanStmt, deleteRoundsOlderThan, height)
	return err
}

const getRecentRounds = `-- name: GetRecentRounds :many
SELECT id, height, round_number, step, start_time, proposer_address, created_at FROM rounds ORDER BY height DESC, round_number DESC LIMIT ?
`

func (q *Queries) GetRecentRounds(ctx context.Context, limit int64) ([]Round, error) {
	rows, err := q.query(ctx, q.getRecentRoundsStmt, getRecentRounds, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Round{}
	for rows.Next() {
		var i Round
		if err := rows.Scan(
			&i.ID,
			&i.Height,
			&i.RoundNumber,
			&i.Step,
			&i.StartTime,
			&i.ProposerAddress,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRound = `-- name: GetRound :one
SELECT id, height, round_number, step, start_time, proposer_address, created_at FROM rounds WHERE height = ? AND round_number = ? LIMIT 1
`

type GetRoundParams struct {
	Height      int64 `json:"height"`
	RoundNumber int64 `json:"round_number"`
}

func (q *Queries) GetRound(ctx context.Context, arg GetRoundParams) (Round, error) {
	row := q.queryRow(ctx, q.getRoundStmt, getRound, arg.Height, arg.RoundNumber)
	var i Round
	err := row.Scan(
		&i.ID,
		&i.Height,
		&i.RoundNumber,
		&i.Step,
		&i.StartTime,
		&i.ProposerAddress,
		&i.CreatedAt,
	)
	return i, err
}

const getRoundsForHeight = `-- name: GetRoundsForHeight :many
SELECT id, height, round_number, step, start_time, proposer_address, created_at FROM rounds WHERE height = ? ORDER BY round_number
`

func (q *Queries) GetRoundsForHeight(ctx context.Context, height int64) ([]Round, error) {
	rows, err := q.query(ctx, q.getRoundsForHeightStmt, getRoundsForHeight, height)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Round{}
	for rows.Next() {
		var i Round
		if err := rows.Scan(
			&i.ID,
			&i.Height,
			&i.RoundNumber,
			&i.Step,
			&i.StartTime,
			&i.ProposerAddress,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoundsInRange = `-- name: GetRoundsInRange :many
SELECT id, height, round_number, step, start_time, proposer_address, created_at FROM rounds 
WHERE height >= ? AND height <= ?
ORDER BY height DESC, round_number DESC
`

type GetRoundsInRangeParams struct {
	Height   int64 `json:"height"`
	Height_2 int64 `json:"height_2"`
}

func (q *Queries) GetRoundsInRange(ctx context.Context, arg GetRoundsInRangeParams) ([]Round, error) {
	rows, err := q.query(ctx, q.getRoundsInRangeStmt, getRoundsInRange, arg.Height, arg.Height_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Round{}
	for rows.Next() {
		var i Round
		if err := rows.Scan(
			&i.ID,
			&i.Height,
			&i.RoundNumber,
			&i.Step,
			&i.StartTime,
			&i.ProposerAddress,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRoundStep = `-- name: UpdateRoundStep :one
UPDATE rounds SET step = ? WHERE height = ? AND round_number = ? RETURNING id, height, round_number, step, start_time, proposer_address, created_at
`

type UpdateRoundStepParams struct {
	Step        sql.NullInt64 `json:"step"`
	Height      int64         `json:"height"`
	RoundNumber int64         `json:"round_number"`
}

func (q *Queries) UpdateRoundStep(ctx context.Context, arg UpdateRoundStepParams) (Round, error) {
	row := q.queryRow(ctx, q.updateRoundStepStmt, updateRoundStep, arg.Step, arg.Height, arg.RoundNumber)
	var i Round
	err := row.Scan(
		&i.ID,
		&i.Height,
		&i.RoundNumber,
		&i.Step,
		&i.StartTime,
		&i.ProposerAddress,
		&i.CreatedAt,
	)
	return i, err
}

const upsertRound = `-- name: UpsertRound :one
INSERT INTO rounds (height, round_number, step, start_time, proposer_address)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT(height, round_number) DO UPDATE SET
    step = excluded.step,
    start_time = excluded.start_time,
    proposer_address = excluded.proposer_address
RETURNING id, height, round_number, step, start_time, proposer_address, created_at
`

type UpsertRoundParams struct {
	Height          int64          `json:"height"`
	RoundNumber     int64          `json:"round_number"`
	Step            sql.NullInt64  `json:"step"`
	StartTime       sql.NullTime   `json:"start_time"`
	ProposerAddress sql.NullString `json:"proposer_address"`
}

func (q *Queries) UpsertRound(ctx context.Context, arg UpsertRoundParams) (Round, error) {
	row := q.queryRow(ctx, q.upsertRoundStmt, upsertRound,
		arg.Height,
		arg.RoundNumber,
		arg.Step,
		arg.StartTime,
		arg.ProposerAddress,
	)
	var i Round
	err := row.Scan(
		&i.ID,
		&i.Height,
		&i.RoundNumber,
		&i.Step,
		&i.StartTime,
		&i.ProposerAddress,
		&i.CreatedAt,
	)
	return i, err
}
