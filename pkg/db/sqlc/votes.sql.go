// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: votes.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createVote = `-- name: CreateVote :one
INSERT INTO votes (height, round_number, validator_address, vote_type, block_hash, signature, timestamp)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, height, round_number, validator_address, vote_type, block_hash, signature, timestamp, created_at
`

type CreateVoteParams struct {
	Height           int64          `json:"height"`
	RoundNumber      int64          `json:"round_number"`
	ValidatorAddress string         `json:"validator_address"`
	VoteType         int64          `json:"vote_type"`
	BlockHash        sql.NullString `json:"block_hash"`
	Signature        sql.NullString `json:"signature"`
	Timestamp        sql.NullTime   `json:"timestamp"`
}

func (q *Queries) CreateVote(ctx context.Context, arg CreateVoteParams) (Vote, error) {
	row := q.queryRow(ctx, q.createVoteStmt, createVote,
		arg.Height,
		arg.RoundNumber,
		arg.ValidatorAddress,
		arg.VoteType,
		arg.BlockHash,
		arg.Signature,
		arg.Timestamp,
	)
	var i Vote
	err := row.Scan(
		&i.ID,
		&i.Height,
		&i.RoundNumber,
		&i.ValidatorAddress,
		&i.VoteType,
		&i.BlockHash,
		&i.Signature,
		&i.Timestamp,
		&i.CreatedAt,
	)
	return i, err
}

const deleteVotesOlderThan = `-- name: DeleteVotesOlderThan :exec
DELETE FROM votes WHERE height < ?
`

func (q *Queries) DeleteVotesOlderThan(ctx context.Context, height int64) error {
	_, err := q.exec(ctx, q.deleteVotesOlderThanStmt, deleteVotesOlderThan, height)
	return err
}

const getVote = `-- name: GetVote :one
SELECT id, height, round_number, validator_address, vote_type, block_hash, signature, timestamp, created_at FROM votes 
WHERE height = ? AND round_number = ? AND validator_address = ? AND vote_type = ?
LIMIT 1
`

type GetVoteParams struct {
	Height           int64  `json:"height"`
	RoundNumber      int64  `json:"round_number"`
	ValidatorAddress string `json:"validator_address"`
	VoteType         int64  `json:"vote_type"`
}

func (q *Queries) GetVote(ctx context.Context, arg GetVoteParams) (Vote, error) {
	row := q.queryRow(ctx, q.getVoteStmt, getVote,
		arg.Height,
		arg.RoundNumber,
		arg.ValidatorAddress,
		arg.VoteType,
	)
	var i Vote
	err := row.Scan(
		&i.ID,
		&i.Height,
		&i.RoundNumber,
		&i.ValidatorAddress,
		&i.VoteType,
		&i.BlockHash,
		&i.Signature,
		&i.Timestamp,
		&i.CreatedAt,
	)
	return i, err
}

const getVotesByType = `-- name: GetVotesByType :many
SELECT id, height, round_number, validator_address, vote_type, block_hash, signature, timestamp, created_at FROM votes 
WHERE height = ? AND round_number = ? AND vote_type = ?
ORDER BY validator_address
`

type GetVotesByTypeParams struct {
	Height      int64 `json:"height"`
	RoundNumber int64 `json:"round_number"`
	VoteType    int64 `json:"vote_type"`
}

func (q *Queries) GetVotesByType(ctx context.Context, arg GetVotesByTypeParams) ([]Vote, error) {
	rows, err := q.query(ctx, q.getVotesByTypeStmt, getVotesByType, arg.Height, arg.RoundNumber, arg.VoteType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Vote{}
	for rows.Next() {
		var i Vote
		if err := rows.Scan(
			&i.ID,
			&i.Height,
			&i.RoundNumber,
			&i.ValidatorAddress,
			&i.VoteType,
			&i.BlockHash,
			&i.Signature,
			&i.Timestamp,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVotesForHeight = `-- name: GetVotesForHeight :many
SELECT id, height, round_number, validator_address, vote_type, block_hash, signature, timestamp, created_at FROM votes WHERE height = ? ORDER BY round_number, vote_type, validator_address
`

func (q *Queries) GetVotesForHeight(ctx context.Context, height int64) ([]Vote, error) {
	rows, err := q.query(ctx, q.getVotesForHeightStmt, getVotesForHeight, height)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Vote{}
	for rows.Next() {
		var i Vote
		if err := rows.Scan(
			&i.ID,
			&i.Height,
			&i.RoundNumber,
			&i.ValidatorAddress,
			&i.VoteType,
			&i.BlockHash,
			&i.Signature,
			&i.Timestamp,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVotesForRound = `-- name: GetVotesForRound :many
SELECT id, height, round_number, validator_address, vote_type, block_hash, signature, timestamp, created_at FROM votes 
WHERE height = ? AND round_number = ?
ORDER BY vote_type, validator_address
`

type GetVotesForRoundParams struct {
	Height      int64 `json:"height"`
	RoundNumber int64 `json:"round_number"`
}

func (q *Queries) GetVotesForRound(ctx context.Context, arg GetVotesForRoundParams) ([]Vote, error) {
	rows, err := q.query(ctx, q.getVotesForRoundStmt, getVotesForRound, arg.Height, arg.RoundNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Vote{}
	for rows.Next() {
		var i Vote
		if err := rows.Scan(
			&i.ID,
			&i.Height,
			&i.RoundNumber,
			&i.ValidatorAddress,
			&i.VoteType,
			&i.BlockHash,
			&i.Signature,
			&i.Timestamp,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVotesForValidator = `-- name: GetVotesForValidator :many
SELECT id, height, round_number, validator_address, vote_type, block_hash, signature, timestamp, created_at FROM votes 
WHERE validator_address = ? AND height >= ?
ORDER BY height DESC, round_number DESC
`

type GetVotesForValidatorParams struct {
	ValidatorAddress string `json:"validator_address"`
	Height           int64  `json:"height"`
}

func (q *Queries) GetVotesForValidator(ctx context.Context, arg GetVotesForValidatorParams) ([]Vote, error) {
	rows, err := q.query(ctx, q.getVotesForValidatorStmt, getVotesForValidator, arg.ValidatorAddress, arg.Height)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Vote{}
	for rows.Next() {
		var i Vote
		if err := rows.Scan(
			&i.ID,
			&i.Height,
			&i.RoundNumber,
			&i.ValidatorAddress,
			&i.VoteType,
			&i.BlockHash,
			&i.Signature,
			&i.Timestamp,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVotingPowerForRound = `-- name: GetVotingPowerForRound :one
SELECT 
    SUM(CASE WHEN v.vote_type = 1 AND v.block_hash IS NOT NULL THEN vs.voting_power ELSE 0 END) as prevote_power,
    SUM(CASE WHEN v.vote_type = 2 AND v.block_hash IS NOT NULL THEN vs.voting_power ELSE 0 END) as precommit_power,
    SUM(vs.voting_power) as total_power
FROM votes v
JOIN validator_snapshots vs ON v.validator_address = vs.validator_address AND v.height = vs.height
WHERE v.height = ? AND v.round_number = ?
`

type GetVotingPowerForRoundParams struct {
	Height      int64 `json:"height"`
	RoundNumber int64 `json:"round_number"`
}

type GetVotingPowerForRoundRow struct {
	PrevotePower   sql.NullFloat64 `json:"prevote_power"`
	PrecommitPower sql.NullFloat64 `json:"precommit_power"`
	TotalPower     sql.NullFloat64 `json:"total_power"`
}

func (q *Queries) GetVotingPowerForRound(ctx context.Context, arg GetVotingPowerForRoundParams) (GetVotingPowerForRoundRow, error) {
	row := q.queryRow(ctx, q.getVotingPowerForRoundStmt, getVotingPowerForRound, arg.Height, arg.RoundNumber)
	var i GetVotingPowerForRoundRow
	err := row.Scan(&i.PrevotePower, &i.PrecommitPower, &i.TotalPower)
	return i, err
}

const upsertVote = `-- name: UpsertVote :one
INSERT INTO votes (height, round_number, validator_address, vote_type, block_hash, signature, timestamp)
VALUES (?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(height, round_number, validator_address, vote_type) DO UPDATE SET
    block_hash = excluded.block_hash,
    signature = excluded.signature,
    timestamp = excluded.timestamp
RETURNING id, height, round_number, validator_address, vote_type, block_hash, signature, timestamp, created_at
`

type UpsertVoteParams struct {
	Height           int64          `json:"height"`
	RoundNumber      int64          `json:"round_number"`
	ValidatorAddress string         `json:"validator_address"`
	VoteType         int64          `json:"vote_type"`
	BlockHash        sql.NullString `json:"block_hash"`
	Signature        sql.NullString `json:"signature"`
	Timestamp        sql.NullTime   `json:"timestamp"`
}

func (q *Queries) UpsertVote(ctx context.Context, arg UpsertVoteParams) (Vote, error) {
	row := q.queryRow(ctx, q.upsertVoteStmt, upsertVote,
		arg.Height,
		arg.RoundNumber,
		arg.ValidatorAddress,
		arg.VoteType,
		arg.BlockHash,
		arg.Signature,
		arg.Timestamp,
	)
	var i Vote
	err := row.Scan(
		&i.ID,
		&i.Height,
		&i.RoundNumber,
		&i.ValidatorAddress,
		&i.VoteType,
		&i.BlockHash,
		&i.Signature,
		&i.Timestamp,
		&i.CreatedAt,
	)
	return i, err
}
